# 算法(JS 版)

## 哈希表

算法中的 “哈希”（Hash）是一种将任意长度的输入数据通过特定规则（称为 “哈希函数”）映射到固定长度的输出值（称为 “哈希值” 或 “散列值”）的技术。它的核心作用是快速检索、数据校验和唯一标识，广泛应用于哈希表、密码加密、数据去重等场景。

### 1.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_ 的那 **两个** 整数，并返回它们的数组下标。

```javascript
/**
 * 两数之和：找出数组中两个数相加等于目标值的索引 时间复杂度 O (n)、空间复杂度 O (n)
 * @param {number[]} nums - 输入数组
 * @param {number} target - 目标和
 * @return {number[]} 两个数的索引数组
 */
var twoSum = function (nums, target) {
  // 存储已遍历的数值及其索引（数值 -> 索引）
  const numToIndex = new Map();

  for (let i = 0; i < nums.length; i++) {
    // 计算当前数值需要的互补数
    const complement = target - nums[i];

    // 若互补数已存在于Map中，直接返回两个索引
    if (numToIndex.has(complement)) {
      return [numToIndex.get(complement), i];
    }

    // 否则将当前数值和索引存入Map
    numToIndex.set(nums[i], i);
  }
};
```

### 2.字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

```javascript
/**
 * 字母异位词分组
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function (strs) {
  // 创建一个Map用于存储分组结果，键为排序后的字符串，值为异位词数组
  const map = new Map();
  for (const str of strs) {
    // 将字符串拆分为字符数组，排序后再拼接成字符串作为键
    const key = str.split("").sort().join("");
    // 如果键已存在，将当前字符串添加到对应数组；否则创建新数组
    if (map.has(key)) {
      map.get(key).push(str);
    } else {
      map.set(key, [str]);
    }
  }
  // 将Map中的值转换为数组返回
  return Array.from(map.values());
  // 使用Array.from和Map.groupBy方法实现
  // Array.from(Map.groupBy(strs, (s) => s.split("").sort().join("")).values())
};
```

### 3.最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

```javascript
/**
 * 最长连续序列
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function (nums) {
  if (nums.length === 0) return 0;

  // 用Set存储所有元素，实现O(1)查找
  const numSet = new Set(nums);
  let maxLength = 0;

  for (const num of numSet) {
    // 只处理序列的起点（即num-1不存在时，才开始向后遍历）
    if (!numSet.has(num - 1)) {
      let currentNum = num;
      let currentLength = 1; // 当前序列长度从1开始

      // 向后查找连续数字
      while (numSet.has(currentNum + 1)) {
        currentNum++;
        currentLength++;
      }

      // 更新最大长度
      maxLength = Math.max(maxLength, currentLength);
    }
  }

  return maxLength;
};
```

## 双指针

算法中的 “双指针” 是一种通过两个指针（或索引）协同遍历数据结构（通常是数组、链表或字符串）来解决问题的技巧。它的核心思想是利用两个指针的移动和位置关系，将原本需嵌套循环（O (n²) 复杂度）的问题优化为线性遍历（O (n) 复杂度），从而高效空间换时间的高效策略。
双指针的核心特点：

1. 指针定义：通常用两个变量（如 i 和 j、left 和 right）表示指针，分别指向数据结构中的不同位置。
2. 移动规则：根据问题场景，指针可以同向移动（如都从左向右）或反向移动（如一个从左、一个从右），移动方向和步长由具体逻辑决定。
3. 适用场景：主要解决线性结构的遍历问题，尤其是涉及 “子序列”“区间”“配对” 的场景（如两数之和、反转链表、移除重复元素等）。

### 1.移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  let n = nums.length;
  // 指向当前已处理的非零元素的末尾
  let left = 0;

  // 第一次遍历：将所有非零元素移到左侧
  for (let i = 0; i < n; i++) {
    if (nums[i] != 0) {
      nums[left] = nums[i];
      left++;
    }
  }

  // 第二次遍历：将剩余位置填充为 0
  for (let i = left; i < n; i++) {
    nums[i] = 0;
  }
};
```

### 2.盛最多水的容器

给定一个长度为 n 的整数数组 height。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i])。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。

```javascript
/**
 * 盛最多水的容器
 * @param {number[]} height
 * @return {number}
 * 思路：使用双指针，分别指向数组的左右边界，计算当前两个指针之间的面积，并更新最大面积。
 * 时间复杂度：O(n)，其中 n 是数组的长度。
 * 空间复杂度：O(1)。
 * 步骤：
 * 1. 定义一个函数 `maxArea`，接收一个参数 `height`，返回一个整数。
 * 2. 初始化两个指针 `left` 和 `right`，分别指向数组的左右边界。
 * 3. 初始化变量 `maxArea` 为 0，用于保存最大面积。
 * 4. 使用 while 循环，当 `left` 小于 `right` 时执行以下步骤：
 *     - 计算当前两个指针之间的面积，并更新 `maxArea`。
 *     - 根据当前两个指针之间的高度，移动指针的位置。
 *      - 如果 `height[left]` 小于 `height[right]`，则将 `left` 向右移动一位；否则将 `right` 向左移动一位。
 * 5. 返回 `maxArea`，即盛最多水的容器的容量。
 * 6. 示例：
 */
var maxArea = function (height) {
  let leftIndex = 0;
  let rightIndex = height.length - 1;
  let max = 0;
  while (leftIndex < rightIndex) {
    const area =
      Math.min(height[leftIndex], height[rightIndex]) *
      (rightIndex - leftIndex);
    if (area > max) {
      max = area;
    } else {
      if (height[leftIndex] < height[rightIndex]) {
        leftIndex++;
      } else {
        rightIndex--;
      }
    }
  }
  return max;
};
```

### 3.三数之和

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

```javascript
/**
 * 三数之和
 * @param {number[]} nums
 * @return {number[][]}
 * 思路：
 * 1. 首先对数组进行排序，以便进行双指针操作。
 * 2. 创建一个空数组 `result` 用于存储结果。
 * 3. 遍历数组，选择一个数作为第一个数。
 * 4. 使用双指针操作，将剩余的数组分为左右两部分。
 * 5. 使用两个指针 `left` 和 `right`，分别指向左右边界。
 * 6. 计算当前三个数的和 `sum`。
 * 7. 根据 `sum` 的大小，移动指针的位置。
 * 8. 如果 `sum` 为 0，则将当前三元组添加到结果数组中，并移动指针位置。
 * 9. 跳过重复的数，并继续遍历。
 * 10. 返回结果数组。
 */
var threeSum = function (nums) {
  // 先对数组进行排序
  nums.sort((a, b) => a - b);
  let result = [];
  // 遍历数组，固定第一个数
  for (let i = 0; i < nums.length - 2; i++) {
    // 如果第一个数大于0，则后面不可能有和为0的组合
    if (nums[i] > 0) break;
    // 跳过重复的第一个数
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let l = i + 1;
    let r = nums.length - 1;
    while (l < r) {
      let sum = nums[i] + nums[l] + nums[r];
      if (sum === 0) {
        result.push([nums[i], nums[l], nums[r]]);
        // 跳过重复的第二个数
        while (l < r && nums[l] === nums[l + 1]) l++;
        // 跳过重复的第三个数
        while (l < r && nums[r] === nums[r - 1]) r--;
        // 移动指针寻找下一组可能的组合
        l++;
        r--;
      } else if (sum < 0) {
        // 和小于0，需要增大和，左指针右移
        l++;
      } else {
        // 和大于0，需要减小和，右指针左移
        r--;
      }
    }
  }
  return result;
};
```

### 4.接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```javascript
var trap = function (height) {
  const trap = function (height) {
    if (!height || height.length < 3) {
      return 0;
    }
    let left = 0; // 左指针
    let right = height.length - 1; // 右指针
    let leftMax = 0; // 左侧最大高度
    let rightMax = 0; // 右侧最大高度
    let sum = 0; // 雨水总量
    // 双指针向中间移动
    while (left < right) {
      // 更新左侧最大高度
      leftMax = Math.max(leftMax, height[left]);
      // 更新右侧最大高度
      rightMax = Math.max(rightMax, height[right]);
      // 根据较小的一边计算雨水
      if (leftMax < rightMax) {
        // 左侧较矮，计算当前位置雨水
        sum += leftMax - height[left];
        left++;
      } else {
        // 右侧较矮，计算当前位置雨水
        sum += rightMax - height[right];
        right--;
      }
    }
    return sum;
  };
};
```

## 滑动窗口

滑动窗口是算法中一种用于高效处理数组或字符串子序列问题的技巧，核心思想是通过一个「动态变化的区间（窗口）」在序列上滑动，从而在线性时间复杂度内解决原本可能需要嵌套循环（O (n²) 或更高）的问题。
简单来说，你可以把这个「窗口」想象成一个可伸缩的矩形框，框住数组 / 字符串中的一部分元素，通过移动窗口的左右边界（扩张或收缩），来找到符合条件的子序列（如最长 / 最短子串、最大 / 最小和等）。
滑动窗口的核心特点：

1. 区间性：窗口由两个指针（通常称为 left 和 right）定义，代表当前处理的子序列范围[left, right]。
2. 动态性：窗口会根据问题条件「滑动」—— 要么右指针右移扩大窗口，要么左指针右移缩小窗口，整个过程中窗口在序列上单向移动，不回溯。
3. 高效性：每个元素最多被 left 和 right 指针各访问一次，因此时间复杂度通常为 O (n)，远优于暴力解法。

### 1. 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。

```javascript
var lengthOfLongestSubstring = function (s) {
  let map = new Map(); // 记录字符最后出现的索引
  let maxLen = 0;
  let left = 0; // 窗口左边界

  for (let right = 0; right < s.length; right++) {
    const char = s[right];
    // 若字符已在窗口内（map有记录且索引≥left），则移动左指针到重复字符的下一位
    if (map.has(char) && map.get(char) >= left) {
      left = map.get(char) + 1;
    }
    // 更新字符最后出现的索引
    map.set(char, right);
    // 计算当前窗口长度，更新最大长度
    maxLen = Math.max(maxLen, right - left + 1);
    console.log(map, char, left, right, maxLen);
  }
  return maxLen;
};
```

### 2. 找到字符串中所有字母异位词

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

```javascript
const sLen = s.length,
  pLen = p.length;
if (sLen < pLen) {
  return [];
}
const ans = [];
const count = Array(26).fill(0);
for (let i = 0; i < pLen; ++i) {
  ++count[s[i].charCodeAt() - "a".charCodeAt()];
  --count[p[i].charCodeAt() - "a".charCodeAt()];
}
let differ = 0;
for (let j = 0; j < 26; ++j) {
  if (count[j] !== 0) {
    ++differ;
  }
}
if (differ === 0) {
  ans.push(0);
}
for (let i = 0; i < sLen - pLen; ++i) {
  if (count[s[i].charCodeAt() - "a".charCodeAt()] === 1) {
    // 窗口中字母 s[i] 的数量与字符串 p 中的数量从不同变得相同
    --differ;
  } else if (count[s[i].charCodeAt() - "a".charCodeAt()] === 0) {
    // 窗口中字母 s[i] 的数量与字符串 p 中的数量从相同变得不同
    ++differ;
  }
  --count[s[i].charCodeAt() - "a".charCodeAt()];

  if (count[s[i + pLen].charCodeAt() - "a".charCodeAt()] === -1) {
    // 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从不同变得相同
    --differ;
  } else if (count[s[i + pLen].charCodeAt() - "a".charCodeAt()] === 0) {
    // 窗口中字母 s[i+pLen] 的数量与字符串 p 中的数量从相同变得不同
    ++differ;
  }
  ++count[s[i + pLen].charCodeAt() - "a".charCodeAt()];

  if (differ === 0) {
    ans.push(i + 1);
  }
}
return ans;
```

## 子串

在算法和字符串处理领域，子串（Substring） 是指从一个完整字符串中，通过指定起始位置和结束位置（或长度）截取出来的、连续的字符序列。它的核心特征是 “连续”—— 这是区分 “子串” 与 “子序列”（Subsequence，字符可不连续）的关键。

1. 连续性：子串的字符在原字符串中必须是 “不间断” 的。例如，从字符串 "abcde" 中截取的 "bcd" 是子串（字符连续），但 "ace" 不是子串（字符间隔排列，属于 “子序列”）。
2. 范围约束：子串的起始位置 start 和结束位置 end 需满足：0 ≤ start ≤ end ≤ 原字符串长度（若用 “0-based 索引”，即起始位置从 0 开始）；串长度 = end - start（若 start = end，则子串为空字符串 ""）。
3. 包含空串：根据定义，每个字符串都包含 “空子串”（如起始和结束位置相同的截取结果），且空子串的数量 = 原字符串长度 + 1（每个位置都能生成一个空串）。
4. 原串关联：子串的字符完全来自原字符串，不允许修改字符顺序或新增字符。

### 1. 和为 K 的子数组

给定一个整数数组和一个整数 k ，请找出该数组中和为 k 的连续子数组的个数。

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var subarraySum = function (nums, k) {
  let count = 0;
  let prefixSum = 0;
  // 哈希表存储前缀和出现的次数，初始前缀和为0的情况出现1次
  const sumCount = new Map();
  sumCount.set(0, 1);
  for (const num of nums) {
    prefixSum += num; // 计算当前前缀和
    // 检查是否存在前缀和等于(prefixSum - k)
    if (sumCount.has(prefixSum - k)) {
      count += sumCount.get(prefixSum - k);
    }
    // 将当前前缀和加入哈希表
    sumCount.set(prefixSum, (sumCount.get(prefixSum) || 0) + 1);
  }
  return count;
};
```

### 2. 滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回 滑动窗口中的最大值 。

```javascript
var maxSlidingWindow = function (nums, k) {
  if (!nums.length || k === 0) return [];
  // 使用数组模拟双端队列
  const deque = [];
  const result = [];
  // 初始化第一个窗口
  for (let i = 0; i < k; i++) {
    // 移除队列中所有小于当前元素的元素
    while (deque.length && deque[deque.length - 1] < nums[i]) {
      deque.pop();
    }
    deque.push(nums[i]);
  }
  // 第一个窗口的最大值
  result.push(deque[0]);
  // 处理剩余元素，形成滑动窗口
  for (let i = k; i < nums.length; i++) {
    // 如果移除的元素是队列中的最大值，则也从队列中移除
    if (deque[0] === nums[i - k]) {
      deque.shift();
    }
    // 维护队列，确保队列是递减的
    while (deque.length && deque[deque.length - 1] < nums[i]) {
      deque.pop();
    }
    deque.push(nums[i]);
    // 当前窗口的最大值是队列的第一个元素
    result.push(deque[0]);
  }
  return result;
};
```

### 3. 最小覆盖子串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function (s, t) {
  // 创建目标字符的频率映射
  const targetMap = new Map();
  for (const char of t) {
    targetMap.set(char, (targetMap.get(char) || 0) + 1);
  }

  // 窗口字符频率映射
  const windowMap = new Map();
  let left = 0; // 左指针
  let right = 0; // 右指针
  let valid = 0; // 已满足的字符种类数量
  let start = 0; // 最小子串的起始索引
  let minLen = Infinity; // 最小子串的长度

  while (right < s.length) {
    // 移动右指针，扩大窗口
    const char = s[right];
    right++;
    // 如果是目标字符，更新窗口映射
    if (targetMap.has(char)) {
      windowMap.set(char, (windowMap.get(char) || 0) + 1);
      // 当窗口中该字符数量等于目标数量时，满足条件的字符种类+1
      if (windowMap.get(char) === targetMap.get(char)) {
        valid++;
      }
    }
    // 当窗口包含所有目标字符时，尝试收缩左指针
    while (valid === targetMap.size) {
      // 更新最小子串
      if (right - left < minLen) {
        start = left;
        minLen = right - left;
      }
      // 移动左指针，缩小窗口
      const leftChar = s[left];
      left++;
      // 如果移除的是目标字符，更新窗口映射
      if (targetMap.has(leftChar)) {
        if (windowMap.get(leftChar) === targetMap.get(leftChar)) {
          valid--;
        }
        windowMap.set(leftChar, windowMap.get(leftChar) - 1);
      }
    }
  }
  // 返回最小子串，如果不存在则返回空字符串
  return minLen === Infinity ? "" : s.substring(start, start + minLen);
};
```
