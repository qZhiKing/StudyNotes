# 算法(JS 版)

## 哈希表

### 1.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_ 的那 **两个** 整数，并返回它们的数组下标。

```javascript
/**
 * 两数之和：找出数组中两个数相加等于目标值的索引 时间复杂度 O (n)、空间复杂度 O (n)
 * @param {number[]} nums - 输入数组
 * @param {number} target - 目标和
 * @return {number[]} 两个数的索引数组
 */
var twoSum = function (nums, target) {
  // 存储已遍历的数值及其索引（数值 -> 索引）
  const numToIndex = new Map();

  for (let i = 0; i < nums.length; i++) {
    // 计算当前数值需要的互补数
    const complement = target - nums[i];

    // 若互补数已存在于Map中，直接返回两个索引
    if (numToIndex.has(complement)) {
      return [numToIndex.get(complement), i];
    }

    // 否则将当前数值和索引存入Map
    numToIndex.set(nums[i], i);
  }
};
```

### 2.字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

```javascript
/**
 * 字母异位词分组
 * @param {string[]} strs
 * @return {string[][]}
 */
var groupAnagrams = function (strs) {
  // 创建一个Map用于存储分组结果，键为排序后的字符串，值为异位词数组
  const map = new Map();
  for (const str of strs) {
    // 将字符串拆分为字符数组，排序后再拼接成字符串作为键
    const key = str.split("").sort().join("");
    // 如果键已存在，将当前字符串添加到对应数组；否则创建新数组
    if (map.has(key)) {
      map.get(key).push(str);
    } else {
      map.set(key, [str]);
    }
  }
  // 将Map中的值转换为数组返回
  return Array.from(map.values());
  // 使用Array.from和Map.groupBy方法实现
  // Array.from(Map.groupBy(strs, (s) => s.split("").sort().join("")).values())
};
```

### 3.最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

```javascript
/**
 * 最长连续序列
 * @param {number[]} nums
 * @return {number}
 */
var longestConsecutive = function (nums) {
  if (nums.length === 0) return 0;

  // 用Set存储所有元素，实现O(1)查找
  const numSet = new Set(nums);
  let maxLength = 0;

  for (const num of numSet) {
    // 只处理序列的起点（即num-1不存在时，才开始向后遍历）
    if (!numSet.has(num - 1)) {
      let currentNum = num;
      let currentLength = 1; // 当前序列长度从1开始

      // 向后查找连续数字
      while (numSet.has(currentNum + 1)) {
        currentNum++;
        currentLength++;
      }

      // 更新最大长度
      maxLength = Math.max(maxLength, currentLength);
    }
  }

  return maxLength;
};
```

## 双指针

### 1.移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  let n = nums.length;
  // 指向当前已处理的非零元素的末尾
  let left = 0;

  // 第一次遍历：将所有非零元素移到左侧
  for (let i = 0; i < n; i++) {
    if (nums[i] != 0) {
      nums[left] = nums[i];
      left++;
    }
  }

  // 第二次遍历：将剩余位置填充为 0
  for (let i = left; i < n; i++) {
    nums[i] = 0;
  }
};
```

### 2.盛最多水的容器

给定一个长度为 n 的整数数组 height。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i])。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。

```javascript
/**
 * 盛最多水的容器
 * @param {number[]} height
 * @return {number}
 * 思路：使用双指针，分别指向数组的左右边界，计算当前两个指针之间的面积，并更新最大面积。
 * 时间复杂度：O(n)，其中 n 是数组的长度。
 * 空间复杂度：O(1)。
 * 步骤：
 * 1. 定义一个函数 `maxArea`，接收一个参数 `height`，返回一个整数。
 * 2. 初始化两个指针 `left` 和 `right`，分别指向数组的左右边界。
 * 3. 初始化变量 `maxArea` 为 0，用于保存最大面积。
 * 4. 使用 while 循环，当 `left` 小于 `right` 时执行以下步骤：
 *     - 计算当前两个指针之间的面积，并更新 `maxArea`。
 *     - 根据当前两个指针之间的高度，移动指针的位置。
 *      - 如果 `height[left]` 小于 `height[right]`，则将 `left` 向右移动一位；否则将 `right` 向左移动一位。
 * 5. 返回 `maxArea`，即盛最多水的容器的容量。
 * 6. 示例：
 */
var maxArea = function (height) {
  let leftIndex = 0;
  let rightIndex = height.length - 1;
  let max = 0;
  while (leftIndex < rightIndex) {
    const area =
      Math.min(height[leftIndex], height[rightIndex]) *
      (rightIndex - leftIndex);
    if (area > max) {
      max = area;
    } else {
      if (height[leftIndex] < height[rightIndex]) {
        leftIndex++;
      } else {
        rightIndex--;
      }
    }
  }
  return max;
};
```

### 3.三数之和

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

```javascript
/**
 * 三数之和
 * @param {number[]} nums
 * @return {number[][]}
 * 思路：
 * 1. 首先对数组进行排序，以便进行双指针操作。
 * 2. 创建一个空数组 `result` 用于存储结果。
 * 3. 遍历数组，选择一个数作为第一个数。
 * 4. 使用双指针操作，将剩余的数组分为左右两部分。
 * 5. 使用两个指针 `left` 和 `right`，分别指向左右边界。
 * 6. 计算当前三个数的和 `sum`。
 * 7. 根据 `sum` 的大小，移动指针的位置。
 * 8. 如果 `sum` 为 0，则将当前三元组添加到结果数组中，并移动指针位置。
 * 9. 跳过重复的数，并继续遍历。
 * 10. 返回结果数组。
 */
var threeSum = function (nums) {
  // 先对数组进行排序
  nums.sort((a, b) => a - b);
  let result = [];
  // 遍历数组，固定第一个数
  for (let i = 0; i < nums.length - 2; i++) {
    // 如果第一个数大于0，则后面不可能有和为0的组合
    if (nums[i] > 0) break;
    // 跳过重复的第一个数
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let l = i + 1;
    let r = nums.length - 1;
    while (l < r) {
      let sum = nums[i] + nums[l] + nums[r];
      if (sum === 0) {
        result.push([nums[i], nums[l], nums[r]]);
        // 跳过重复的第二个数
        while (l < r && nums[l] === nums[l + 1]) l++;
        // 跳过重复的第三个数
        while (l < r && nums[r] === nums[r - 1]) r--;
        // 移动指针寻找下一组可能的组合
        l++;
        r--;
      } else if (sum < 0) {
        // 和小于0，需要增大和，左指针右移
        l++;
      } else {
        // 和大于0，需要减小和，右指针左移
        r--;
      }
    }
  }
  return result;
};
```

### 4.接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```javascript
var trap = function (height) {
  const trap = function (height) {
    if (!height || height.length < 3) {
      return 0;
    }
    let left = 0; // 左指针
    let right = height.length - 1; // 右指针
    let leftMax = 0; // 左侧最大高度
    let rightMax = 0; // 右侧最大高度
    let sum = 0; // 雨水总量
    // 双指针向中间移动
    while (left < right) {
      // 更新左侧最大高度
      leftMax = Math.max(leftMax, height[left]);
      // 更新右侧最大高度
      rightMax = Math.max(rightMax, height[right]);
      // 根据较小的一边计算雨水
      if (leftMax < rightMax) {
        // 左侧较矮，计算当前位置雨水
        sum += leftMax - height[left];
        left++;
      } else {
        // 右侧较矮，计算当前位置雨水
        sum += rightMax - height[right];
        right--;
      }
    }
    return sum;
  };
};
```
